package handlers

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"math/big"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/jung-kurt/gofpdf"

	db "github.com/careecodes/RentDaddy/internal/db/generated"
	"github.com/careecodes/RentDaddy/middleware"
	"github.com/go-chi/chi/v5"

	"github.com/careecodes/RentDaddy/pkg/handlers/documenso"
)

/*

Lease Creation Summary:
1. Generate PDF template (don't store it - hardcode it) - (GeneratePDFHandler, GenerateLeaseTemplatePDF)
2. Have Admin fill details on frontend and call - (GenerateAndUploadLeasePDF)
3. Generate lease PDF from Documenso client and store direct link for signing - (GenerateAndUploadLeasePDF)
4. When lease is signed - flag it as signed - (DocumensoWebhookHandler)

Lease Signing Summary:

Lease Retrieval Summary:

Lease Termination Summary:

Lease Renewal Summary:

*/
// Temp dir for storing generated leases
var tempDir = os.Getenv("TEMP_DIR")

// LeaseHandler encapsulates dependencies for lease-related handlers
type LeaseHandler struct {
	pool             *pgxpool.Pool
	queries          *db.Queries
	documenso_client *documenso.DocumensoClient
}

// NewLeaseHandler initializes a LeaseHandler
func NewLeaseHandler(pool *pgxpool.Pool, queries *db.Queries) *LeaseHandler {
	baseURL := os.Getenv("DOCUMENSO_API_URL")
	apiKey := os.Getenv("DOCUMENSO_API_KEY")
	log.Printf("Documenso API URL: %s", baseURL)
	log.Printf("Documenso API Key: %s", apiKey)

	if tempDir == "" {
		tempDir = "/app/temp" // Default fallback
	}
	return &LeaseHandler{
		pool:             pool,
		queries:          queries,
		documenso_client: documenso.NewDocumensoClient(baseURL, apiKey),
	}
}

// Create Lease Request Struct
type CreateLeaseRequest struct {
	TenantID      int64     `json:"tenant_id"`
	LandlordID    int64     `json:"landlord_id"`
	ApartmentID   int64     `json:"apartment_id"`
	StartDate     time.Time `json:"start_date"`
	EndDate       time.Time `json:"end_date"`
	RentAmount    float64   `json:"rent_amount"`
	Status        string    `json:"lease_status"`
	ExternalDocID string    `json:"external_doc_id,omitempty"`
	DocumentTitle string    `json:"document_title"`
	CreatedBy     int64     `json:"created_by"`
}

// Convert `CreateLeaseRequest` to `db.CreateLeaseParams`
func (r CreateLeaseRequest) ToCreateLeaseParams(leasePdf []byte) db.CreateLeaseParams {
	return db.CreateLeaseParams{
		LeaseVersion:   1,
		ExternalDocID:  r.ExternalDocID,
		TenantID:       r.TenantID,
		LandlordID:     r.LandlordID,
		ApartmentID:    r.ApartmentID,
		LeaseStartDate: pgtype.Date{Time: r.StartDate, Valid: !r.StartDate.IsZero()},
		LeaseEndDate:   pgtype.Date{Time: r.EndDate, Valid: !r.EndDate.IsZero()},
		RentAmount:     pgtype.Numeric{Int: big.NewInt(int64(r.RentAmount)), Exp: -2, Valid: true},
		Status:         db.LeaseStatus(r.Status),
		LeasePdf:       leasePdf,
		CreatedBy:      r.CreatedBy,
	}
}

// Create Lease Response Struct
type CreateLeaseResponse struct {
	LeaseID         int64  `json:"lease_id"`
	ExternalDocID   string `json:"external_doc_id,omitempty"`
	Status          string `json:"lease_status"`
	LeasePDF        string `json:"lease_pdf,omitempty"`
	LeaseSigningURL string `json:"lease_signing_url"`
}

// Convert `db.Lease` to `CreateLeaseResponse`
func NewCreateLeaseResponse(lease db.Lease) CreateLeaseResponse {
	return CreateLeaseResponse{
		LeaseID:         lease.ID,
		ExternalDocID:   lease.ExternalDocID,
		Status:          string(lease.Status),
		LeasePDF:        base64.StdEncoding.EncodeToString(lease.LeasePdf),
		LeaseSigningURL: "",
	}
}
func (h *LeaseHandler) DocumensoWebhookHandler(w http.ResponseWriter, r *http.Request) {
	var payload struct {
		DocumentID string `json:"document_id"`
		EventType  string `json:"event_type"`
		Signer     struct {
			Email string `json:"email"`
			Name  string `json:"name"`
			Role  string `json:"role"`
		} `json:"signer"`
	}

	// Parse the webhook payload
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		http.Error(w, "Invalid webhook payload", http.StatusBadRequest)
		return
	}

	// Log the webhook event
	log.Printf("Received Documenso webhook: %s for document %s from %s (%s)",
		payload.EventType, payload.DocumentID, payload.Signer.Name, payload.Signer.Email)

	// Find leases by external document ID
	leases, err := h.queries.ListLeases(r.Context())
	if err != nil {
		log.Printf("Error listing leases: %v", err)
		http.Error(w, "Failed to list leases", http.StatusInternalServerError)
		return
	}

	// Find the lease with matching external doc ID
	var targetLease *db.Lease
	for _, lease := range leases {
		if lease.ExternalDocID == payload.DocumentID {
			targetLease = &lease
			break
		}
	}

	if targetLease == nil {
		log.Printf("No lease found with external doc ID %s", payload.DocumentID)
		http.Error(w, "Lease not found", http.StatusNotFound)
		return
	}

	// Handle different event types
	switch payload.EventType {
	case "document.opened":
		// Document has been opened by a recipient
		log.Printf("Document %s opened by %s", payload.DocumentID, payload.Signer.Email)

	case "document.signed":
		// Document has been signed by someone
		isLandlord := strings.Contains(strings.ToLower(payload.Signer.Email), "rentdaddy") ||
			strings.Contains(strings.ToLower(payload.Signer.Email), "admin@")

		if isLandlord {
			// Landlord has signed
			log.Printf("Lease %d signed by landlord %s", targetLease.ID, payload.Signer.Name)
		} else {
			// If it's the tenant signing, mark the lease as signed
			err := h.queries.MarkLeaseAsSigned(r.Context(), targetLease.ID)
			if err != nil {
				log.Printf("Error marking lease %d as signed: %v", targetLease.ID, err)
				http.Error(w, "Failed to update lease status", http.StatusInternalServerError)
				return
			}
			log.Printf("Lease %d marked as signed by tenant %s", targetLease.ID, payload.Signer.Name)
		}

	case "document.completed":
		// All required signatures have been collected
		// Update lease status to active
		params := db.UpdateLeaseParams{
			ID:             targetLease.ID,
			TenantID:       targetLease.TenantID,
			Status:         db.LeaseStatus("active"),
			LeaseStartDate: targetLease.LeaseStartDate,
			LeaseEndDate:   targetLease.LeaseEndDate,
			RentAmount:     targetLease.RentAmount,
			UpdatedBy:      targetLease.LandlordID, // Using landlord ID for the update
		}

		err := h.queries.UpdateLease(r.Context(), params)
		if err != nil {
			log.Printf("Error updating lease %d status to active: %v", targetLease.ID, err)
			http.Error(w, "Failed to update lease status", http.StatusInternalServerError)
			return
		}
		log.Printf("Lease %d marked as active after all signatures received", targetLease.ID)

		// Download the fully signed document and save it
		signedDocData, err := h.documenso_client.DownloadDocument(payload.DocumentID)
		if err != nil {
			log.Printf("Warning: Could not download signed document: %v", err)
		} else {
			// Update the lease with the signed PDF
			err := h.queries.UpdateLeasePDF(r.Context(), db.UpdateLeasePDFParams{
				ID:        targetLease.ID,
				LeasePdf:  signedDocData,
				UpdatedBy: targetLease.LandlordID,
			})

			if err != nil {
				log.Printf("Warning: Failed to save signed PDF: %v", err)
			} else {
				log.Printf("Successfully saved signed PDF for lease %d", targetLease.ID)
			}
		}
	}

	w.WriteHeader(http.StatusOK)
	fmt.Fprintln(w, "Webhook processed successfully")
}

// Modified GenerateAndUploadLeasePDF handler
func (h *LeaseHandler) GenerateAndUploadLeasePDF(w http.ResponseWriter, r *http.Request) {
	var req struct {
		TenantName      string  `json:"tenant_name"`
		PropertyAddress string  `json:"property_address"`
		RentAmount      float64 `json:"rent_amount"`
		LeaseTemplateID int64   `json:"lease_template_id"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		return
	}

	// Generate lease PDF
	leasePDF, err := h.GenerateLeaseTemplatePDF("Lease Agreement", req.TenantName, req.RentAmount, req.PropertyAddress)
	if err != nil {
		http.Error(w, "Failed to generate lease PDF", http.StatusInternalServerError)
		return
	}

	// Log first 100 bytes if the lease is a valid file
	log.Printf("First 100 bytes of PDF: %s", base64.StdEncoding.EncodeToString(leasePDF[:100]))

	// Upload to Documenso
	docID, err := h.documenso_client.UploadDocument(leasePDF, "Lease Agreement")
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to upload lease PDF: %v", err), http.StatusInternalServerError)
		return
	}

	// Store lease in database
	leaseParams := db.CreateLeaseParams{
		TenantID:      req.LeaseTemplateID,
		ExternalDocID: docID,
		Status:        db.LeaseStatus("Pending Signature"),
		RentAmount:    pgtype.Numeric{Int: big.NewInt(int64(req.RentAmount)), Exp: -2, Valid: true},
	}

	leaseID, err := h.queries.CreateLease(r.Context(), leaseParams)
	if err != nil {
		http.Error(w, "Failed to store lease in database", http.StatusInternalServerError)
		return
	}

	// Return signing link
	resp := map[string]string{
		"lease_id":         fmt.Sprintf("%d", leaseID),
		"lease_sign_url":   fmt.Sprintf("https://documenso.com/sign/%s", docID),
		"pdf_saved_to_tmp": "true",
		"tenant_name":      req.TenantName,
		"pdf_info":         "PDF files are saved to mounted volumes (/app/tmp, /app/temp). Check these directories in your Docker container or on your host machine if properly mounted.",
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(resp)
}

// Updated SavePDFToDisk function to create a full lease PDF
func SavePDFToDisk(pdf *gofpdf.Fpdf, title, tenantName string) {
	// Get sanitized tenant name for filename
	sanitizedTenantName := strings.ReplaceAll(tenantName, " ", "_")
	sanitizedTenantName = strings.ReplaceAll(sanitizedTenantName, "/", "_")

	// Generate unique filename
	timestamp := time.Now().Format("20060102-150405")
	filename := fmt.Sprintf("lease_%s_%s.pdf", timestamp, sanitizedTenantName)

	// Try all possible Docker-mounted directories
	possibleDirs := []string{
		"/app/tmp",
		"/app/temp",
		"/tmp",
		"/var/tmp",
	}

	// Get environment variable if set
	if envDir := os.Getenv("TEMP_DIR"); envDir != "" {
		possibleDirs = append([]string{envDir}, possibleDirs...)
	}

	// Try each directory
	for _, dir := range possibleDirs {
		// Create directory if it doesn't exist
		if err := os.MkdirAll(dir, 0755); err != nil {
			log.Printf("Could not create directory %s: %v", dir, err)
			continue
		}

		filepath := filepath.Join(dir, filename)

		// Create a new PDF for saving to disk
		diskPdf := gofpdf.New("P", "mm", "A4", "")

		// Recreate the full PDF content
		diskPdf.AddPage()

		// Set margins and content
		diskPdf.SetMargins(20, 20, 20)
		diskPdf.SetX(20)
		diskPdf.SetY(20)

		// Title
		diskPdf.SetFont("Arial", "B", 16)
		diskPdf.Cell(0, 10, "Residential Lease Agreement")
		diskPdf.Ln(15)

		// Current date
		currentDate := time.Now().Format("January 2, 2006")

		// Agreement date
		diskPdf.SetFont("Arial", "", 12)
		diskPdf.Cell(0, 10, fmt.Sprintf("This Lease Agreement is entered into on %s between:", currentDate))
		diskPdf.Ln(15)

		// Landlord section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(40, 10, "Landlord")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 12)
		diskPdf.Cell(0, 10, "RentDaddy Property Management LLC")
		diskPdf.Ln(15)

		// Tenant section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(40, 10, "Tenant")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 12)
		diskPdf.Cell(0, 10, tenantName)
		diskPdf.Ln(15)

		// Property section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(40, 10, "PROPERTY")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 12)
		diskPdf.Cell(0, 10, "123 Main Street, Dallas, Texas 77777, USA")
		diskPdf.Ln(25)

		// Lease term section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(40, 10, "LEASE TERM")
		diskPdf.Ln(10)

		// Calculate start date (first day of next month) and end date (12 months later)
		now := time.Now()
		startDate := time.Date(now.Year(), now.Month()+1, 1, 0, 0, 0, 0, now.Location())
		endDate := startDate.AddDate(1, 0, -1) // 12 months minus 1 day

		diskPdf.SetFont("Arial", "", 12)
		diskPdf.Cell(40, 10, "Fixed Lease: From")
		diskPdf.Cell(60, 10, startDate.Format("January 2, 2006")+" To")
		diskPdf.Cell(60, 10, endDate.Format("January 2, 2006"))
		diskPdf.Ln(25)

		// Rent section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(40, 10, "RENT")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 12)
		diskPdf.Cell(40, 10, "Monthly Rent:")
		diskPdf.Cell(20, 10, "$")
		diskPdf.Cell(60, 10, "1,500.00")
		diskPdf.Ln(10)

		diskPdf.Cell(0, 10, "Due on the 1st of each month.")
		diskPdf.Ln(15)

		// Security deposit section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(40, 10, "SECURITY DEPOSIT")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 12)
		diskPdf.Cell(40, 10, "Amount:")
		diskPdf.Cell(20, 10, "$")
		diskPdf.Cell(60, 10, "1,500.00")
		diskPdf.Ln(15)

		// Late rent section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(40, 10, "LATE RENT")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 12)
		diskPdf.Cell(0, 10, "If unpaid within 5 days, a late fee of 20% of rent applies.")
		diskPdf.Ln(25)

		// Signatures section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(40, 10, "SIGNATURES")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 12)
		diskPdf.Cell(0, 10, "Landlord Signature:")
		diskPdf.Ln(10)
		diskPdf.Cell(0, 10, "___________________________________")
		diskPdf.Ln(10)

		diskPdf.Cell(40, 10, "Date:")
		diskPdf.Ln(10)
		diskPdf.Cell(0, 10, "___________________________________")
		diskPdf.Ln(15)

		diskPdf.SetFont("Arial", "", 12)
		diskPdf.Cell(0, 10, "Tenant Signature:")
		diskPdf.Ln(10)
		diskPdf.Cell(0, 10, "___________________________________")
		diskPdf.Ln(10)

		diskPdf.Cell(40, 10, "Date:")
		diskPdf.Ln(10)
		diskPdf.Cell(0, 10, "___________________________________")
		diskPdf.Ln(10)

		// Page number
		diskPdf.Cell(0, 10, "1")

		// Add a second page with additional terms
		diskPdf.AddPage()

		// Title for second page
		diskPdf.SetFont("Arial", "B", 14)
		diskPdf.Cell(0, 10, "ADDITIONAL TERMS AND CONDITIONS")
		diskPdf.Ln(15)

		// Maintenance section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(0, 10, "MAINTENANCE AND REPAIRS")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 11)
		diskPdf.MultiCell(0, 6, "Tenant shall maintain the Property in a clean and sanitary condition and shall promptly notify Landlord of any needed repairs. Tenant shall be responsible for the cost of repairing any damage caused by Tenant's negligence or misuse. Landlord shall be responsible for maintaining the structural elements of the Property and all mechanical systems.", "", "", false)
		diskPdf.Ln(10)

		// Utilities section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(0, 10, "UTILITIES")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 11)
		diskPdf.MultiCell(0, 6, "Tenant shall be responsible for the payment of all utilities and services supplied to the Property, including electricity, gas, water, sewage, garbage collection, telephone, internet, and cable/satellite TV.", "", "", false)
		diskPdf.Ln(10)

		// Pets section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(0, 10, "PETS")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 11)
		diskPdf.MultiCell(0, 6, "No pets are allowed on the Property without Landlord's prior written consent. If pets are permitted, Tenant shall pay a non-refundable pet fee of $300 and an additional pet deposit of $500, which may be used to cover any damage caused by the pet.", "", "", false)
		diskPdf.Ln(10)

		// Insurance section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(0, 10, "RENTER'S INSURANCE")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 11)
		diskPdf.MultiCell(0, 6, "Tenant is required to maintain renter's insurance throughout the term of this lease with coverage of at least $100,000 for personal liability. Landlord shall be named as an interested party on the policy, and Tenant shall provide proof of insurance to Landlord prior to occupancy.", "", "", false)
		diskPdf.Ln(10)

		// Use of premises section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(0, 10, "USE OF PREMISES")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 11)
		diskPdf.MultiCell(0, 6, "The Property shall be used as a residence only. Tenant shall not engage in any illegal activities on the Property. Tenant shall not create or permit any nuisance, including excessive noise that disturbs other residents.", "", "", false)
		diskPdf.Ln(10)

		// Right of entry section
		diskPdf.SetFont("Arial", "B", 12)
		diskPdf.Cell(0, 10, "RIGHT OF ENTRY")
		diskPdf.Ln(10)

		diskPdf.SetFont("Arial", "", 11)
		diskPdf.MultiCell(0, 6, "Landlord or Landlord's agents may enter the Property at reasonable times with 24 hours' notice to inspect the Property, make repairs, or show the Property to prospective tenants or purchasers. In case of emergency, Landlord may enter the Property without prior notice.", "", "", false)
		diskPdf.Ln(10)

		// Page number
		diskPdf.SetFont("Arial", "", 10)
		diskPdf.Cell(0, 10, "2")

		// Try to save to this location
		err := diskPdf.OutputFileAndClose(filepath)
		if err != nil {
			log.Printf("Could not save PDF to %s: %v", filepath, err)
			continue
		}

		// Successfully saved
		log.Printf("✅ PDF successfully saved to: %s", filepath)

		// Try to make readable for host user
		os.Chmod(filepath, 0666)

		// Write a small text file with the location for easier finding
		locationFile := filepath[:len(filepath)-4] + "_location.txt"
		locationContent := fmt.Sprintf("The PDF was saved to: %s\nTimestamp: %s",
			filepath, time.Now().Format("2006-01-02 15:04:05"))
		os.WriteFile(locationFile, []byte(locationContent), 0666)

		return
	}

	log.Printf("⚠️ WARNING: Could not save PDF to any directory. Check your Docker volume mounts.")
}

// LeaseWithSignersRequest represents the request for creating a lease with signers
type LeaseWithSignersRequest struct {
	// User IDs for database relations
	TenantID    int64 `json:"tenant_id"`
	LandlordID  int64 `json:"landlord_id,omitempty"` // Only used as fallback if auth context is missing
	ApartmentID int64 `json:"apartment_id"`

	// Tenant information (used if tenant_id lookup fails)
	TenantName  string `json:"tenant_name"`
	TenantEmail string `json:"tenant_email"`

	// Property information
	PropertyAddress string  `json:"property_address"`
	RentAmount      float64 `json:"rent_amount"`

	// Lease dates
	StartDate string `json:"start_date"` // Format: YYYY-MM-DD
	EndDate   string `json:"end_date"`   // Format: YYYY-MM-DD

	// Document metadata
	DocumentTitle string `json:"document_title,omitempty"`
}

func (h LeaseHandler) GetLeaseWithFields(w http.ResponseWriter, r *http.Request) {
	leaseIDStr := chi.URLParam(r, "leaseID")
	leaseID, err := strconv.ParseInt(leaseIDStr, 10, 64)
	if err != nil {
		http.Error(w, "Invalid lease ID", http.StatusBadRequest)
		return
	}

	// Retrieve lease details from DB
	lease, err := h.queries.GetLeaseByID(r.Context(), leaseID)
	if err != nil {
		http.Error(w, "Lease not found", http.StatusNotFound)
		return
	}

	// Get preloaded lease template document ID from Documenso
	documentID := lease.ExternalDocID
	if documentID == "" {
		http.Error(w, "Lease document not linked to Documenso", http.StatusNotFound)
		return
	}

	// Define form values
	formValues := map[string]string{
		"tenant_name":      "John Doe",
		"property_address": "123 Main St",
		"lease_start_date": lease.LeaseStartDate.Time.Format("2006-01-02"),
		"lease_end_date":   lease.LeaseEndDate.Time.Format("2006-01-02"),
		"rent_amount":      lease.RentAmount.Int.String(),
	}

	// Iterate over form values and update fields in Documenso
	for field, value := range formValues {
		err := h.documenso_client.SetField(documentID, field, value)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to update field %s: %v", field, err), http.StatusInternalServerError)
			return
		}
	}

	// Return confirmation response
	w.WriteHeader(http.StatusOK)
	fmt.Fprintln(w, "Lease fields updated successfully in Documenso")
}

// GetLeasePDF retrieves the generated lease PDF
func (h LeaseHandler) GetLeasePDF(w http.ResponseWriter, r *http.Request) {
	leaseIDStr := chi.URLParam(r, "leaseID")
	leaseID, err := strconv.ParseInt(leaseIDStr, 10, 64)
	if err != nil {
		http.Error(w, "Invalid lease ID", http.StatusBadRequest)
		return
	}

	lease, err := h.queries.GetLeaseByID(r.Context(), leaseID)
	if err != nil {
		http.Error(w, "Lease not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/pdf")
	w.WriteHeader(http.StatusOK)
	w.Write(lease.LeasePdf)
}

// CreateFullLeaseAgreement generates a complete lease PDF, uploads it to Documenso,
// and fills out all the necessary fields
func (h *LeaseHandler) CreateFullLeaseAgreement(w http.ResponseWriter, r *http.Request) {
	// 1. Parse request
	var req LeaseWithSignersRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("Error parsing request: %v", err)
		http.Error(w, fmt.Sprintf("Invalid request format: %v", err), http.StatusBadRequest)
		return
	}

	// 2. Validate required fields
	if req.TenantName == "" || req.TenantEmail == "" {
		http.Error(w, "Tenant name and email are required", http.StatusBadRequest)
		return
	}

	if req.PropertyAddress == "" {
		http.Error(w, "Property address is required", http.StatusBadRequest)
		return
	}

	if req.RentAmount <= 0 {
		http.Error(w, "Valid rent amount is required", http.StatusBadRequest)
		return
	}

	if req.StartDate == "" || req.EndDate == "" {
		http.Error(w, "Lease start and end dates are required", http.StatusBadRequest)
		return
	}

	// 3. Parse and validate dates
	startDate, err := time.Parse("2006-01-02", req.StartDate)
	if err != nil {
		http.Error(w, "Invalid start date format. Use YYYY-MM-DD", http.StatusBadRequest)
		return
	}

	endDate, err := time.Parse("2006-01-02", req.EndDate)
	if err != nil {
		http.Error(w, "Invalid end date format. Use YYYY-MM-DD", http.StatusBadRequest)
		return
	}

	if endDate.Before(startDate) {
		http.Error(w, "End date must be after start date", http.StatusBadRequest)
		return
	}

	// Get landlord details
	landlordName := "RentDaddy Property Management"
	landlordEmail := "admin@rentdaddy.com"

	// 4. Generate the full lease PDF
	pdfData, err := h.GenerateComprehensiveLeaseAgreement(
		req.DocumentTitle,
		landlordName,
		req.TenantName,
		req.PropertyAddress,
		req.RentAmount,
		startDate,
		endDate,
	)
	if err != nil {
		log.Printf("Error generating lease PDF: %v", err)
		http.Error(w, "Failed to generate lease PDF", http.StatusInternalServerError)
		return
	}

	// 5. Create signers array for Documenso
	signers := []documenso.Signer{
		{
			Name:  req.TenantName,
			Email: req.TenantEmail,
			Role:  documenso.SignerRoleSigner,
		},
		{
			Name:  landlordName,
			Email: landlordEmail,
			Role:  documenso.SignerRoleViewer,
		},
	}

	// 6. Upload to Documenso with signers
	documentTitle := "Residential Lease Agreement"
	if req.DocumentTitle != "" {
		documentTitle = req.DocumentTitle
	}

	log.Println("Uploading lease to Documenso...")
	docID, err := h.documenso_client.UploadDocumentWithSigners(pdfData, documentTitle, signers)
	if err != nil {
		log.Printf("Error uploading to Documenso: %v", err)
		http.Error(w, fmt.Sprintf("Failed to upload lease PDF: %v", err), http.StatusInternalServerError)
		return
	}
	log.Printf("Successfully uploaded lease. DocID: %s", docID)

	// 7. Set all the document fields with proper values
	if err := h.setLeaseFields(docID, landlordName, req.TenantName, req.PropertyAddress,
		startDate, endDate, req.RentAmount); err != nil {
		log.Printf("Warning: Failed to populate some lease fields: %v", err)
		// Continue anyway - the fields might still be populated manually
	}

	// 8. Create the lease record in the database
	leaseParams := db.CreateLeaseParams{
		LeaseVersion:   1,
		ExternalDocID:  docID,
		TenantID:       req.TenantID,
		LandlordID:     req.LandlordID,
		ApartmentID:    req.ApartmentID,
		LeaseStartDate: pgtype.Date{Time: startDate, Valid: true},
		LeaseEndDate:   pgtype.Date{Time: endDate, Valid: true},
		RentAmount:     pgtype.Numeric{Int: big.NewInt(int64(req.RentAmount * 100)), Exp: -2, Valid: true},
		Status:         db.LeaseStatus("pending_approval"),
		LeasePdf:       pdfData,
		CreatedBy:      req.LandlordID,
		UpdatedBy:      req.LandlordID,
	}

	leaseID, err := h.queries.CreateLease(r.Context(), leaseParams)
	if err != nil {
		log.Printf("Error creating lease in database: %v", err)
		http.Error(w, "Failed to store lease in database", http.StatusInternalServerError)
		return
	}

	// 9. Return success response with lease details
	resp := map[string]interface{}{
		"lease_id":        leaseID,
		"external_doc_id": docID,
		"lease_sign_url":  fmt.Sprintf("https://documenso.com/sign/%s", docID),
		"tenant_name":     req.TenantName,
		"tenant_email":    req.TenantEmail,
		"status":          "pending_approval",
		"message":         "Lease agreement created successfully and sent for signing",
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(resp)
}

// setLeaseFields populates all fields in the Documenso document
func (h *LeaseHandler) setLeaseFields(docID, landlordName, tenantName, propertyAddress string,
	startDate, endDate time.Time, rentAmount float64) error {

	// Define all fields that need to be set
	leaseData := map[string]string{
		"agreement_date":   time.Now().Format("January 2, 2006"),
		"landlord_name":    landlordName,
		"tenant_name":      tenantName,
		"property_address": propertyAddress,
		"lease_start_date": startDate.Format("January 2, 2006"),
		"lease_end_date":   endDate.Format("January 2, 2006"),
		"rent_amount":      fmt.Sprintf("%.2f", rentAmount),
		"security_deposit": fmt.Sprintf("%.2f", rentAmount), // Set security deposit equal to one month's rent
	}

	// Try to set each field individually with appropriate error handling
	var setErrors []error
	for field, value := range leaseData {
		if err := h.documenso_client.SetField(docID, field, value); err != nil {
			log.Printf("Warning: Failed to set field %s: %v", field, err)
			setErrors = append(setErrors, fmt.Errorf("failed to set %s: %v", field, err))

			// Add a small delay between API calls
			time.Sleep(200 * time.Millisecond)
		} else {
			log.Printf("Successfully set field %s = %s", field, value)
			// Add a small delay between API calls
			time.Sleep(200 * time.Millisecond)
		}
	}

	if len(setErrors) > 0 {
		return fmt.Errorf("failed to set %d/%d fields", len(setErrors), len(leaseData))
	}

	return nil
}

// GenerateComprehensiveLeaseAgreement creates a full, properly formatted lease PDF
func (h *LeaseHandler) GenerateComprehensiveLeaseAgreement(
	title, landlordName, tenantName, propertyAddress string,
	rentAmount float64, startDate, endDate time.Time) ([]byte, error) {

	// Create a new PDF document
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.SetMargins(20, 20, 20)

	// Add first page - main lease agreement
	pdf.AddPage()

	// Title
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(0, 10, "Residential Lease Agreement")
	pdf.Ln(15)

	// Agreement date
	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, fmt.Sprintf("This Lease Agreement is entered into on __________________ between:"))
	pdf.Ln(15)

	// Landlord section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "Landlord")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(15)

	// Tenant section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "Tenant")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(15)

	// Property section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "PROPERTY")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.MultiCell(0, 6, fmt.Sprintf("The rental property is located at:"), "", "", false)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(15)

	// Lease term section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "LEASE TERM")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "Fixed Lease: From")
	pdf.Cell(60, 10, "__________________ To")
	pdf.Cell(60, 10, "__________________")
	pdf.Ln(25)

	// Rent section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "RENT")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "Monthly Rent:")
	pdf.Cell(20, 10, "$")
	pdf.Cell(60, 10, "________________________")
	pdf.Ln(10)

	pdf.Cell(0, 10, "Due on the 1st of each month.")
	pdf.Ln(15)

	// Security deposit section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "SECURITY DEPOSIT")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "Amount:")
	pdf.Cell(20, 10, "$")
	pdf.Cell(60, 10, "________________________")
	pdf.Ln(15)

	// Late rent section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "LATE RENT")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "If unpaid within 5 days, a late fee of 20% of rent applies.")
	pdf.Ln(25)

	// Signatures section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "SIGNATURES")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "Landlord Signature:")
	pdf.Ln(10)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(10)

	pdf.Cell(40, 10, "Date:")
	pdf.Ln(10)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(15)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "Tenant Signature:")
	pdf.Ln(10)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(10)

	pdf.Cell(40, 10, "Date:")
	pdf.Ln(10)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(10)

	// Page number
	pdf.Cell(0, 10, "1")

	// Add a second page with additional terms
	pdf.AddPage()

	// Title for second page
	pdf.SetFont("Arial", "B", 14)
	pdf.Cell(0, 10, "ADDITIONAL TERMS AND CONDITIONS")
	pdf.Ln(15)

	// Maintenance section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(0, 10, "MAINTENANCE AND REPAIRS")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 11)
	pdf.MultiCell(0, 6, "Tenant shall maintain the Property in a clean and sanitary condition and shall promptly notify Landlord of any needed repairs. Tenant shall be responsible for the cost of repairing any damage caused by Tenant's negligence or misuse. Landlord shall be responsible for maintaining the structural elements of the Property and all mechanical systems.", "", "", false)
	pdf.Ln(10)

	// Utilities section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(0, 10, "UTILITIES")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 11)
	pdf.MultiCell(0, 6, "Tenant shall be responsible for the payment of all utilities and services supplied to the Property, including electricity, gas, water, sewage, garbage collection, telephone, internet, and cable/satellite TV.", "", "", false)
	pdf.Ln(10)

	// Pets section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(0, 10, "PETS")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 11)
	pdf.MultiCell(0, 6, "No pets are allowed on the Property without Landlord's prior written consent. If pets are permitted, Tenant shall pay a non-refundable pet fee of $300 and an additional pet deposit of $500, which may be used to cover any damage caused by the pet.", "", "", false)
	pdf.Ln(10)

	// Insurance section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(0, 10, "RENTER'S INSURANCE")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 11)
	pdf.MultiCell(0, 6, "Tenant is required to maintain renter's insurance throughout the term of this lease with coverage of at least $100,000 for personal liability. Landlord shall be named as an interested party on the policy, and Tenant shall provide proof of insurance to Landlord prior to occupancy.", "", "", false)
	pdf.Ln(10)

	// Page number
	pdf.SetFont("Arial", "", 10)
	pdf.Cell(0, 10, "2")

	// Get PDF bytes
	var buf bytes.Buffer
	err := pdf.Output(&buf)
	if err != nil {
		return nil, fmt.Errorf("failed to generate lease PDF: %w", err)
	}

	return buf.Bytes(), nil
}

// GenerateLeaseTemplatePDF creates a lease PDF and ensures it's saved to a Docker-mounted volume
func (h *LeaseHandler) GenerateLeaseTemplatePDF(title string, tenantName string, rentAmount float64, propertyAddress string) ([]byte, error) {
	// First, create PDF in memory
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()

	// Set margins and content (same as before)
	pdf.SetMargins(20, 20, 20)
	pdf.SetX(20)
	pdf.SetY(20)

	// Title
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(0, 10, "Residential Lease Agreement")
	pdf.Ln(15)

	// Agreement date
	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "This Lease Agreement is entered into on __________________________ between:")
	pdf.Ln(15)

	// Landlord section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "Landlord")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(15)

	// Tenant section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "Tenant")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(15)

	// Property section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "PROPERTY")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, fmt.Sprintf("The rental property is located at: ________________________ Street in Dallas, Dallas, Texas 77777, USA"))
	pdf.Ln(25)

	// Lease term section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "LEASE TERM")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "Fixed Lease: From")
	pdf.Cell(60, 10, "__________________________ To")
	pdf.Cell(60, 10, "__________________________")
	pdf.Ln(25)

	// Rent section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "RENT")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "Monthly Rent:")
	pdf.Cell(20, 10, "$")
	pdf.Cell(60, 10, "________________________")
	pdf.Ln(10)

	pdf.Cell(0, 10, "Due on the 1st of each month.")
	pdf.Ln(15)

	// Security deposit section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "SECURITY DEPOSIT")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, "Amount:")
	pdf.Cell(20, 10, "$")
	pdf.Cell(60, 10, "________________________")
	pdf.Ln(15)

	// Late rent section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "LATE RENT")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "If unpaid within 5 days, a late fee of 20% of rent applies.")
	pdf.Ln(25)

	// Signatures section
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "SIGNATURES")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "Landlord Signature:")
	pdf.Ln(10)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(10)

	pdf.Cell(40, 10, "Date:")
	pdf.Ln(10)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(15)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 10, "Tenant Signature:")
	pdf.Ln(10)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(10)

	pdf.Cell(40, 10, "Date:")
	pdf.Ln(10)
	pdf.Cell(0, 10, "___________________________________")
	pdf.Ln(10)

	// Page number
	pdf.Cell(0, 10, "1")

	// Get PDF bytes for API upload
	var buf bytes.Buffer
	err := pdf.Output(&buf)
	if err != nil {
		return nil, fmt.Errorf("failed to generate lease PDF: %w", err)
	}
	go func() {
		// Run SavePDFToDisk in a goroutine to avoid blocking to disk in multiple possible locations (Docker volume mounts)
		SavePDFToDisk(pdf, title, tenantName)
	}()

	return buf.Bytes(), nil
}

// UploadLeaseWithSigners handles lease generation with tenant and landlord signers
func (h *LeaseHandler) UploadLeaseWithSigners(w http.ResponseWriter, r *http.Request) {
	// 1. Parse request body - keep this part unchanged
	var req LeaseWithSignersRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("Error parsing request: %v", err)
		http.Error(w, fmt.Sprintf("Invalid request format: %v", err), http.StatusBadRequest)
		return
	}

	// Set default document title if not provided - unchanged
	if req.DocumentTitle == "" {
		req.DocumentTitle = "Residential Lease Agreement"
	}

	// 2. Get admin user ID using your existing middleware
	var adminID int64
	var adminEmail, adminName string

	// Use your existing middleware function to get the admin user
	clerkUser, err := middleware.GetClerkUser(r)
	if err != nil || clerkUser == nil {
		log.Printf("Warning: Failed to get authenticated user: %v", err)
		// For development purposes, use fallback admin
		if req.LandlordID > 0 {
			adminID = req.LandlordID
		} else {
			adminID = 100 // Default fallback for testing
		}

		// CHANGE: Add default admin email and name if not found
		adminEmail = "admin@rentdaddy.com"
		adminName = "RentDaddy Property Management"
	} else {
		// Get admin from database using Clerk ID
		adminUser, err := h.queries.GetUser(r.Context(), clerkUser.ID)
		if err != nil {
			log.Printf("Error getting admin from database: %v", err)
			// Use fallback if we can't find admin
			if req.LandlordID > 0 {
				adminID = req.LandlordID
			} else {
				adminID = 100 // Default fallback
			}

			// CHANGE: Add default admin email and name if database lookup fails
			adminEmail = "admin@rentdaddy.com"
			adminName = "RentDaddy Property Management"
		} else {
			adminID = adminUser.ID
			adminEmail = adminUser.Email
			adminName = fmt.Sprintf("%s %s", adminUser.FirstName, adminUser.LastName)
		}
	}

	// 3. Validate tenant details
	if req.TenantID <= 0 && (req.TenantName == "" || req.TenantEmail == "") {
		http.Error(w, "Either valid tenant ID or tenant name/email are required", http.StatusBadRequest)
		return
	}

	if req.TenantID > 0 {
		// Get tenant by ID from database
		tenant, err := h.queries.GetUserByID(r.Context(), req.TenantID)
		if err != nil {
			log.Printf("Error getting tenant with ID %d: %v", req.TenantID, err)
			// If we can't find the tenant by ID but have name/email, continue with request data
			if req.TenantName == "" || req.TenantEmail == "" {
				http.Error(w, fmt.Sprintf("Tenant with ID %d not found", req.TenantID), http.StatusNotFound)
				return
			}
		} else {
			// Use tenant data from database
			req.TenantName = fmt.Sprintf("%s %s", tenant.FirstName, tenant.LastName)
			req.TenantEmail = tenant.Email
		}
	}

	// 4. Validate apartment ID and check for existing active leases
	if req.ApartmentID <= 0 {
		http.Error(w, "Valid apartment ID is required", http.StatusBadRequest)
		return
	}

	// Check if apartment exists and if it has an active lease
	leases, err := h.queries.ListLeases(r.Context())
	if err != nil {
		log.Printf("Error listing leases: %v", err)
		http.Error(w, "Failed to verify apartment availability", http.StatusInternalServerError)
		return
	}

	// Check if apartment has an active lease
	for _, lease := range leases {
		if lease.ApartmentID == req.ApartmentID && lease.Status == "active" {
			http.Error(w, fmt.Sprintf("Apartment %d already has an active lease", req.ApartmentID), http.StatusConflict)
			return
		}
	}
	// Create signers array for Documenso
	signers := []documenso.Signer{
		{
			Name:  req.TenantName,
			Email: req.TenantEmail,
			Role:  documenso.SignerRoleSigner,
		},
	}

	// CHANGE: Always add the landlord as a recipient, either as VIEWER or SIGNER as appropriate
	// This ensures the landlord is always part of the signing process
	signers = append(signers, documenso.Signer{
		Name:  adminName,
		Email: adminEmail,
		Role:  documenso.SignerRoleSigner, // Change to SIGNER so landlord can also sign
	})
	// 5. Parse and validate dates
	startDate, err := time.Parse("2006-01-02", req.StartDate)
	if err != nil {
		http.Error(w, "Invalid start date format. Use YYYY-MM-DD", http.StatusBadRequest)
		return
	}

	endDate, err := time.Parse("2006-01-02", req.EndDate)
	if err != nil {
		http.Error(w, "Invalid end date format. Use YYYY-MM-DD", http.StatusBadRequest)
		return
	}

	if endDate.Before(startDate) {
		http.Error(w, "End date must be after start date", http.StatusBadRequest)
		return
	}

	// 6. Generate lease PDF with tenant info
	leasePDF, err := h.GenerateComprehensiveLeaseAgreement(
		req.DocumentTitle,
		adminName,
		req.TenantName,
		req.PropertyAddress,
		req.RentAmount,
		startDate,
		endDate,
	)
	if err != nil {
		log.Printf("Error generating lease PDF: %v", err)
		http.Error(w, "Failed to generate lease PDF", http.StatusInternalServerError)
		return
	}

	log.Println("Lease PDF generated successfully.")

	// 8. Upload to Documenso with signers
	docID, err := h.documenso_client.UploadDocumentWithSigners(leasePDF, req.DocumentTitle, signers)
	if err != nil {
		log.Printf("Error uploading to Documenso: %v", err)
		http.Error(w, fmt.Sprintf("Failed to upload lease PDF: %v", err), http.StatusInternalServerError)
		return
	}

	// 9. Set lease fields in Documenso
	leaseData := map[string]string{
		"agreement_date":   time.Now().Format("January 2, 2006"),
		"landlord_name":    adminName,
		"tenant_name":      req.TenantName,
		"property_address": req.PropertyAddress,
		"lease_start_date": startDate.Format("January 2, 2006"),
		"lease_end_date":   endDate.Format("January 2, 2006"),
		"rent_amount":      fmt.Sprintf("%.2f", req.RentAmount),
		"security_deposit": fmt.Sprintf("%.2f", req.RentAmount), // Commonly the same as rent
	}

	// Instead of attempting all fields at once, try each field individually
	log.Printf("Setting lease fields for document %s", docID)
	fieldsSet := 0
	for field, value := range leaseData {
		// Try to set each field individually and continue even if one fails
		if err := h.documenso_client.SetField(docID, field, value); err != nil {
			log.Printf("Warning: Failed to set field %s: %v", field, err)
		} else {
			fieldsSet++
			// Add a small delay between API calls
			time.Sleep(200 * time.Millisecond)
		}
	}
	log.Printf("Successfully set %d/%d lease fields", fieldsSet, len(leaseData))

	// 10. Store lease in database with all validated data
	leaseParams := db.CreateLeaseParams{
		LeaseVersion:   1,
		ExternalDocID:  docID,
		TenantID:       req.TenantID,
		LandlordID:     adminID,
		ApartmentID:    req.ApartmentID,
		LeaseStartDate: pgtype.Date{Time: startDate, Valid: true},
		LeaseEndDate:   pgtype.Date{Time: endDate, Valid: true},
		RentAmount:     pgtype.Numeric{Int: big.NewInt(int64(req.RentAmount * 100)), Exp: -2, Valid: true},
		Status:         db.LeaseStatus("pending_approval"),
		LeasePdf:       leasePDF,
		CreatedBy:      adminID,
		UpdatedBy:      adminID,
	}

	leaseID, err := h.queries.CreateLease(r.Context(), leaseParams)
	if err != nil {
		log.Printf("Error creating lease in database: %v", err)
		http.Error(w, fmt.Sprintf("Failed to store lease in database: %v", err), http.StatusInternalServerError)
		return
	}

	// 11. Return success response with lease details
	resp := map[string]interface{}{
		"lease_id":        leaseID,
		"external_doc_id": docID,
		"lease_sign_url":  fmt.Sprintf("https://documenso.com/sign/%s", docID),
		"tenant_name":     req.TenantName,
		"tenant_email":    req.TenantEmail,
		"status":          "pending_approval",
		"fields_set":      fieldsSet,
		"total_fields":    len(leaseData),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	if err := json.NewEncoder(w).Encode(resp); err != nil {
		log.Printf("Error encoding response: %v", err)
	}
}



// setLeaseFields populates all fields in the Documenso document
func (h *LeaseHandler) setLeaseFields(docID, landlordName, tenantName, propertyAddress string,
	startDate, endDate time.Time, rentAmount float64) error {

	// Define all fields that need to be set
	leaseData := map[string]string{
		"agreement_date":   time.Now().Format("January 2, 2006"),
		"landlord_name":    landlordName,
		"tenant_name":      tenantName,
		"property_address": propertyAddress,
		"lease_start_date": startDate.Format("January 2, 2006"),
		"lease_end_date":   endDate.Format("January 2, 2006"),
		"rent_amount":      fmt.Sprintf("%.2f", rentAmount),
		"security_deposit": fmt.Sprintf("%.2f", rentAmount), // Set security deposit equal to one month's rent
	}

	// Try to set each field individually with appropriate error handling
	var setErrors []error
	for field, value := range leaseData {
		if err := h.documenso_client.SetField(docID, field, value); err != nil {
			log.Printf("Warning: Failed to set field %s: %v", field, err)
			setErrors = append(setErrors, fmt.Errorf("failed to set %s: %v", field, err))

			// Add a small delay between API calls
			time.Sleep(200 * time.Millisecond)
		} else {
			log.Printf("Successfully set field %s = %s", field, value)
			// Add a small delay between API calls
			time.Sleep(200 * time.Millisecond)
		}
	}

	if len(setErrors) > 0 {
		return fmt.Errorf("failed to set %d/%d fields", len(setErrors), len(leaseData))
	}

	return nil
}